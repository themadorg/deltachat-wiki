---
title: تشخیص تناقضات
description: مستندات تشخیص تناقضات برای webxdc.
category: وضعیت مشترک
---

# تشخیص تناقضات

تغییرات در وضعیت مشترک می‌توانند متناقض در نظر گرفته شوند وقتی دو شرط محقق شوند:

1. آن‌ها بخش همپوشانی یک ساختمان داده را تحت تأثیر قرار دهند، مانند اینکه دو کاربر هر دو سعی کنند عنوان همان آیتم فهرست کارها را تنظیم کنند

2. آن‌ها [هم‌زمان](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) باشند -
به این معنی که شرکت‌کنندگان در سیستم نمی‌توانند
به‌طور قطعی ترتیب وقوع آن‌ها را تعیین کنند

_به‌روزرسانی‌های هم‌زمان که بر داده‌های نامرتبط تأثیر می‌گذارند_
بدون مشکل قابل حل هستند، همان‌طور که
_به‌روزرسانی‌های متوالی بر داده‌های مرتبط_.

هم‌زمانی از دیدگاه کلاینت
در طرح‌هایی که از یک سرور مرکزی با کلاینت‌های آنلاین استفاده می‌کنند، عملاً قابل چشم‌پوشی است.
برنامه‌های وب متمرکز با سرور HTTP همیشه آنلاین مرکزی
مثال محبوبی از این مدل هستند.
سرورهای HTTP متمرکز نه تنها می‌توانند
[ترتیب کامل](https://en.wikipedia.org/wiki/Total_order) پیام‌ها را تضمین کنند
بلکه می‌توانند به‌طور مرجع تناقضات را حل کنند
و «منبع حقیقت» واحدی را
برای تمام برنامه‌های وب مرتبط اجرا شده روی دستگاه‌های کلاینت فراهم کنند.
در مدل پیام‌رسانی غیرمتمرکز، و به‌ویژه با پیام‌رسانی رمزگذاری سرتاسری،
هم ترتیب کامل پیام‌ها و هم «منبع حقیقت واحد» قابل فرض نیستند.

## حل تناقض در برنامه‌های webxdc

بسیاری از برنامه‌های webxdc قادر به تولید تناقض نیستند،
یا به این دلیل که از APIهای ارتباط شبکه استفاده نمی‌کنند،
یا به این دلیل که هر ساختمان داده مشخص فقط یک نویسنده دارد.
برای مثال، بسیاری از [بازی‌های webxdc](https://webxdc.org/apps/) موجود جدول امتیازات بالا ارائه می‌دهند
و نحوه امتیازگیری کاربران معمولاً به چت گزارش داده می‌شود.
چنین برنامه بازی‌ای به سادگی امتیاز بالای کاربرشان را ارسال می‌کند
و همه داده‌های امتیازات بالای رسیده را جمع‌آوری
و در لیست مرتب شده به کاربرانشان نشان خواهند داد.
اگر پیامی گم شود یا پیام‌ها دوباره مرتب شوند به سختی مشکلی وجود دارد.
در نهایت همه تقریباً همان لیست امتیازات بالا را خواهند دید.
ارزش توجه دارد که برنامه میزبان webxdc
ممکن است به یک کاربر واحد اجازه استفاده از چندین دستگاه را بدهد.
برای مثال، یک برنامه مدیریت رمز عبور webxdc می‌تواند در چت «پیام‌های ذخیره شده»
یا «پیام‌های خودی» استفاده شود تا فقط دستگاه‌های یک کاربر واحد وضعیت برنامه را به اشتراک بگذارند.
چنین تنظیم چند دستگاهی قبلاً تشکیل یک سیستم P2P حداقلی را می‌دهد
که در آن ترتیب کامل پیام‌ها تضمین نمی‌شود
و منبع حقیقت واحدی وجود ندارد.

برنامه‌های webxdc می‌توانند از [`webxdc.sendUpdate()`](../specification/sendUpdate.html#sendupdate)
و [`setUpdateListener`](https://docs.webxdc.org/spec/setUpdateListener.html)
برای ارسال و دریافت داده به و از دستگاه‌های دیگر استفاده کنند.
سپس لازم است مکانیزمی فراهم شود
که از طریق آن تمام کلاینت‌ها بتوانند ترتیب کاملی برای همه به‌روزرسانی‌ها تعیین کنند،
یا بتوانند به‌طور دیگری به دیدگاه سازگار مشترکی در دستگاه‌های مختلف برسند،
پس از تحویل همه پیام‌ها.
راه‌حل کامل برای این موضوع ساده نیست،
اما مکانیزم‌های نسبتاً ساده‌ای وجود دارند که می‌توانند
[ترتیب جزئی](https://en.wikipedia.org/wiki/Partially_ordered_set) برای به‌روزرسانی‌ها فراهم کنند.

## ترتیب جزئی

ممکن است وسوسه‌انگیز باشد که یک مُهر زمانی به هر به‌روزرسانی اضافه
و آن‌ها را بر اساس این مقدار مرتب کنیم.
با این حال، ساعت‌های فیزیکی کامپیوترها می‌توانند نادقیق باشند،
بنابراین تکیه بر آن‌ها برای مرتب‌سازی پیام‌ها می‌تواند مشکل‌ساز باشد،
و احتمالاً به پیام‌هایی منجر شود که به نظر می‌رسد
از گذشته یا آینده غیرممکنِ دور آمده‌اند.
در سطح نظری‌تر،
[زمان یک اندازه‌گیری کاملاً ذهنی است](https://en.wikipedia.org/wiki/Time_dilation)،
بنابراین حتی با ساعت‌های اتمی کاملاً قابل اعتماد نیز نقص‌های اساسی در این رویکرد وجود دارد.

[ساعت‌های منطقی](https://en.wikipedia.org/wiki/Logical_clock) گزینه قابل اعتمادتری هستند
که امکان مرتب‌سازی اکثر رویدادها را تحت شرایط عادی فراهم می‌کنند.
برای مثال، [مُهرهای زمانی Lamport](https://en.wikipedia.org/wiki/Lamport_timestamp)
شماره ترتیبی در هر به‌روزرسانی شامل می‌شوند
و شمارنده خود را به یکی بیشتر از بزرگترین مقدار شناخته شده افزایش می‌دهند.
چندین پیام با شماره ترتیب یکسان
سپس می‌توانند به عنوان نشانه‌ای از هم‌زمانی تلقی شوند.

این روش هم به دلیل سادگی نسبی
و هم مقدار کم سربار معرفی شده محبوب است.
برای مثال، توسط [Yjs](https://yjs.dev/) استفاده می‌شود
که بعداً در این فصل بحث خواهد شد.

رویکرد محبوب دیگری که صریح‌تر
اما فشرده‌تر نیست شامل استفاده از
[توابع هش رمزنگاری](https://en.wikipedia.org/wiki/Cryptographic_hash_function) است.
به جای یک شمارنده واحد،
پیام‌ها لیستی از هش‌های پیام‌های قبلی را شامل می‌شوند
که در زمان نویسندگی پیام شناخته شده بودند.
این امکان تشخیص زمانی که پیامی تحویل نشده
یا تاریخچه پیام به‌نحوی تغییر یافته را فراهم می‌کند
(اگرچه مورد اخیر احتمالاً نگرانی برنامه‌های webxdc نیست).
تنوعاتی از این تکنیک در [Git](https://git-scm.com/)،
[BitTorrent](https://en.wikipedia.org/wiki/BitTorrent)،
[Bitcoin](https://en.wikipedia.org/wiki/Bitcoin)،
[Matrix](https://en.wikipedia.org/wiki/Matrix_(protocol))،
[Secure Scuttlebutt](https://en.wikipedia.org/wiki/Secure_Scuttlebutt)،
[IPFS](https://en.wikipedia.org/wiki/InterPlanetary_File_System)
و بسیاری پروتکل‌های دیگر با هدف حل مشکلات مختلف اعمال شده‌اند.

هر یک از این تکنیک‌های کلی مفهوم _علیت_ را منتقل می‌کنند.
تکنیک‌های حل تناقض می‌توانند از نظر محاسباتی گران باشند،
یا نیاز به مداخله دستی انسان داشته باشند.
ردیابی علیت و رد کردن تناقضات
اولین خط دفاع مؤثر در سیستم‌های همتا به همتا هستند
که در آن‌ها ترتیب پیام‌ها تضمین نمی‌شود.

با دانش نحوه وقوع تناقضات در سیستم‌های توزیع‌شده،
و برخی تکنیک‌های پایه برای کاهش فراوانی آن‌ها،
اکنون می‌توانیم به معرفی فناوری در حال تکامل
طراحی شده برای حذف کامل آن‌ها بپردازیم.

