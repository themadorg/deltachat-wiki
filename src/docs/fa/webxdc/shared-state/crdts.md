---
title: نظریه نوع‌های داده تکرارشونده بدون تناقض (CRDT)
description: مستندات نظریه CRDT برای webxdc.
category: وضعیت مشترک
---

# نظریه نوع‌های داده تکرارشونده بدون تناقض (CRDTها)

بخش قبلی شرایطی را توصیف کرد
که در آن به‌روزرسانی‌های وضعیت مشترک می‌توانند متناقض باشند،
و برخی تکنیک‌های مورد استفاده برای شناسایی چنین تناقضاتی را معرفی کرد.
این بخش [**نوع‌های داده تکرارشونده بدون تناقض**](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) را ارائه می‌دهد،
فناوری‌ای که به‌طور خودکار چنین تغییراتی را
بدون نیاز به مرجع مرکزی حل می‌کند.
اصطلاحات تخصصی را تعریف خواهد کرد
که به نظر می‌رسد بسیاری را از پذیرش CRDTها بازمی‌دارد،
برخی مثال‌های پایه ارائه می‌دهد،
انتظارات روشنی از آنچه می‌توانند و نمی‌توانند انجام دهند تعیین می‌کند،
و امیدواریم شما را آماده می‌کند تا از باگ‌های مرتبط با هم‌زمانی اجتناب کنید
و از مزایای برنامه‌های آفلاین-اول بهره‌مند شوید.

## اصطلاحات

همانند مفهوم متعارف
[نوع داده](https://en.wikipedia.org/wiki/Data_type)،
یک CRDT می‌تواند با مجموعه مقادیر ممکن،
مجموعه عملیات معتبر روی آن مقادیر،
و نمایش سطح پایین آن‌ها تعریف شود.
اغلب راه‌های بسیاری برای نمایش اطلاعات مشابه وجود دارد.
دانستن محدوده مقادیر ممکن
و عملیات دقیق مورد نیاز برای مورد استفاده خاص شما
به شما کمک می‌کند مؤثرترین طراحی را برای کار انتخاب کنید.

_CRDTها_ فراتر از نوع‌های داده پایه‌ای هستند
که تقریباً در هر زبان برنامه‌نویسی موجودند
زیرا طراحی شده‌اند تا
[تکرار](https://en.wikipedia.org/wiki/Replication_(computing)) شوند
در چندین فرآیند.
این فرآیندها ممکن است روی همان ماشین اجرا شوند،
اما معمولاً در یک شبکه پراکنده هستند.
برای انجام این کار آن‌ها عموماً متدهای اضافی تعریف می‌کنند
تا وضعیت همتاهای دور را ردیابی کنند،
حداقل مجموعه به‌روزرسانی‌هایی که آن همتاها فاقد آن هستند را تحویل دهند،
و نشان دهند کدام به‌روزرسانی‌ها شناخته شده‌اند
تا همتاهای دیگر بتوانند همان خدمات را برای ما انجام دهند.

مهم‌تر از همه، CRDTها **بدون تناقض** هستند،
به این معنی که طراحی شده‌اند تا
هر ترکیب ممکنی از عملیات هم‌زمان را برای یک نوع داده مشخص
به شیوه‌ای [قطعی](https://en.wikipedia.org/wiki/Deterministic_system#In_computer_science) مدیریت کنند.
وضعیت‌های همتاها می‌توانند به‌طور موقت واگرا شوند،
اما یک CRDT [سازگاری نهایی](https://en.wikipedia.org/wiki/Eventual_consistency) را تضمین می‌کند،
یعنی هر دو همتایی که از مجموعه یکسانی از به‌روزرسانی‌ها آگاه هستند
به وضعیت یکسانی همگرا خواهند شد.

## مثال‌ها

یک [شمارش](https://www.merriam-webster.com/dictionary/tally)
نسبت به بسیاری از نوع‌های داده دیگر نسبتاً ساده است.
اگر دو نفر بخواهند تعداد کتاب‌ها را روی دو قفسه بشمارند،
می‌توانند هر کدام یکی از قفسه‌ها را بشمارند و سپس نتایجشان را جمع کنند.
همچنین می‌توانند به‌طور مداوم اعداد را اعلام کنند
و هم اکتشافات خود و هم آنچه می‌شنوند را به جمع ذهنی اضافه کنند.
اهمیتی ندارد که مقادیر با چه ترتیبی ثبت شوند
زیرا جمع [جابه‌جایی](https://en.wikipedia.org/wiki/Commutative_property#Commutative_operations) دارد،
حداقل برای اعداد ساده.
نکته مهم درک این است که علی‌رغم هرگونه شباهت ظاهری،
یک _شمارش_ از یک _عدد_ متفاوت است
زیرا عدد عملیات بسیاری را پشتیبانی می‌کند که نمی‌توانند به _هر ترتیبی_ اعمال شوند.
با انتخاب تنها پشتیبانی از جمع
می‌توان تضمین کرد که شمارش‌های تمام همتاها به مقدار نهایی یکسانی همگرا خواهند شد.

برای نسخه کمی پیچیده‌تر شمارش
می‌توانیم شرایطی را در نظر بگیریم که سازمان‌دهندگان یک جشنواره
باید اطمینان حاصل کنند که هیچ‌یک از مناطق آن از حداکثر ظرفیت ایمن تجاوز نکند.
شمارش تعداد شرکت‌کنندگان در هر منطقه
با ثبت تعداد افرادی که از ورودی‌ها و خروجی‌ها عبور می‌کنند نگهداری می‌شود.
به جای فرض اینکه تمام جمع‌ها مربوط به یک مقدار واحد هستند مانند مثال آخر،
می‌توانیم عملیات خود را تغییر دهیم تا
هم _منطقه مربوطه_ و هم _تغییر در اشغال_ مشخص شوند.
بنابراین، وقتی سه نفر از منطقه A به منطقه B می‌روند،
ایست بازرسی می‌تواند دو رویداد ثبت کند (`update('A', -3); update('B', 3)`).
تا زمانی که تمام ایست بازرسی‌ها برای یک منطقه مشخص
بتوانند با تأخیر نسبتاً کمی با یکدیگر ارتباط برقرار کنند
باید بتوانند از اطلاعات موجود
تصمیم بگیرند که آیا شرکت‌کنندگان بیشتری را از ایست بازرسی خود بپذیرند.

این مثال‌ها CRDTهای بسیار پایه‌ای با مسائل محدود دامنه را توصیف می‌کنند.
اگر چنین مسئله‌ای دارید که به‌خوبی به عملیات جابه‌جایی نگاشت می‌شود
ممکن است ارزشمند باشد یک CRDT تخصصی برای حل آن طراحی کنید،
و ممکن است اطمینان‌بخش باشد بدانید که
این ساختمان‌های داده همیشه نیاز به پیچیدگی زیادی ندارند.

در عمل ترتیب عملیات مهم خواهد بود،
به‌ویژه هنگام کار با ساختمان‌های داده مانند لیست‌ها یا آرایه‌ها.
اگر دو عملیات هم‌زمان آیتم‌هایی را به انتهای یک لیست اضافه کنند
منطقی است که آن‌ها را به ترتیب دلخواهی قرار دهیم.
برای مثال:

1. _آلیس_ و _باب_ هر دو سعی می‌کنند عناصری را به کپی‌های محلی خود از یک لیست خالی اضافه کنند (`let list = []`)
    * آلیس `list.push(5)` انجام می‌دهد
    * باب `list.push(7)` انجام می‌دهد
2. وقتی از ویرایش‌های یکدیگر آگاه شوند، حل خودکار تغییرات هم‌زمان به‌صورت `[5, 7]` یا `[7, 5]` معتبر خواهد بود، حداقل تحت اکثر شرایط
3. حالا، اگر _چارلی_ بیاید، از هر دو تغییر آگاه شود و سپس سعی کند آیتم دیگری اضافه کند، بیشتر افراد انتظار دارند به انتها اضافه شود:
    * چارلی `list.push(11)` انجام می‌دهد
4. نتایج معتبر `[5, 7, 11]` یا `[7, 5, 11]` هستند

همان‌طور که در بخش آخر این فصل توصیف شد،
تکنیک‌هایی برای تمایز بین این دو نوع شرایط وجود دارد
که مشخص می‌کنند کدام عملیات هم‌زمان یا متوالی هستند.
برای حل خودکار چنین تناقضاتی هنگام وقوع عملیات هم‌زمان،
چنین نوع‌هایی باید استراتژی‌های قطعی نیز تعریف کنند
تا به تمام شرکت‌کنندگان اجازه دهند ترتیب یکسانی از مجموعه‌ای از تمام گزینه‌های ممکن انتخاب کنند.
کتابخانه‌های مختلف CRDT ممکن است از استراتژی‌های حل مختلفی استفاده کنند،
اما در بیشتر موارد انتخاب مکانیزم اساساً دلخواه است
تا زمانی که برخی شرایط پایه را برآورده کند.

## انتظارات

CRDTها طبقه بسیار گسترده‌ای از ساختمان‌های داده با تنوع وسیع پیاده‌سازی‌های ممکن هستند،
حتی برای نوع‌های ظاهراً مشابه.
چیزی که همه آن‌ها مشترک دارند تضمین _سازگاری نهایی_ است،
که تمام شرکت‌کنندگان در یک سیستم روی وضعیت نهایی ساختار توافق خواهند کرد
تا زمانی که همه از مجموعه یکسانی از به‌روزرسانی‌ها آگاه باشند.
تمام به‌روزرسانی‌ها _به‌طور خودکار_ ادغام خواهند شد، صرف‌نظر از ترتیب یا درجه تقاطع آن‌ها.

با این حال، اینکه وضعیت نهایی ساختار با
انتظارات کسانی که از برنامه استفاده می‌کنند مطابقت دارد یا نه مسئله _طراحی_ است.
اگر دو همتا هم‌زمان عددی را از `5` به `6` افزایش دهند،
یک سیستم ممکن است تصمیم بگیرد که دو همتا موافقند وضعیت جدید باید `6` باشد،
در حالی که سیستم دیگری ممکن است دو بار افزایش به `7` را مناسب بداند.

در صورتی که یکی از نوع‌های داده پایه یک CRDT عمومی مانند
[Yjs](https://yjs.dev/) با انتظارات شما _مطابقت نداشته باشد_ کتابخانه
ممکن است هنوز برای استفاده شما مناسب باشد.
رفتارهای مختلف را می‌توان با ترکیب نوع‌های داخلی به نوع‌های پیچیده‌تر بدست آورد.
_Yjs_ تغییرات هم‌زمان به یک عدد را به عنوان دو تخصیص تلقی می‌کند.
اگر ترجیح می‌دهید به عنوان افزایش تلقی شوند، می‌توانید به جای آن
هر جمع را به عنوان عضو جدید آرایه‌ای از اعداد برای جمع شدن رمزگذاری کنید.
مقدار سطح بالاتر سپس می‌تواند هر زمان که لازم است از آرایه مشتق شود،
در حالی که نمایش سطح پایین‌تر به عنوان روشی ساده‌تر برای دستیابی به سازگاری عمل می‌کند.
رایج است که برنامه‌های مشارکتی ساخته شده بر CRDTها از این نوع الگوی _طرحواره_ پیروی کنند،
که در آن اقدامات کاربر به عملیات روی وضعیت مشترک ترجمه می‌شوند،
و تغییرات دور به رابط کاربری منتشر می‌شوند.

یک CRDT خوب طراحی شده تمام جنبه‌های مرتب‌سازی پیام‌ها را مدیریت می‌کند،
شامل پیاده‌سازی داخلی ساعت منطقی،
تشخیص هم‌زمانی،
و حل تغییرات همپوشان.
این به همتاها امکان می‌دهد به‌روزرسانی‌ها را هنگام کاملاً آفلاین بودن صف‌بندی کنند،
و وضعیت محلی خود را با دیگران هنگامی که دوباره قادر به ارتباط هستند ادغام کنند.
اگرچه این رفتار می‌تواند برای توسعه‌دهندگان برنامه بسیار مفید باشد،
ممکن است شما را کاملاً از فکر کردن درباره شرایط شبکه آزاد نکند.
وضعیت برنامه _با سازگاری نهایی_ عموماً باید به عنوان
ذهنی تلقی شود، که اگر به داشتن سرور به عنوان مرجع عادت دارید تغییر قابل توجهی است.
این بدان معناست که رفتار شرطی که معمولاً به عنوان _بله_ و _خیر_ تلقی می‌کنید،
ممکن است بیشتر مانند _در حال حاضر_ و _هنوز نه_ رفتار کند.

این بخش ویژگی‌های CRDTها را که عمدتاً نظری هستند بحث کرده است.
بخش بعدی مثال‌های عملی‌تری با استفاده از **Yjs** ارائه خواهد داد،
با تمرکز خاص بر نحوه استفاده آن برای دستیابی به اهداف رایج
در برنامه‌های webxdc همان‌طور که در پلتفرم‌های webxdc موجود پیاده‌سازی شده‌اند.

