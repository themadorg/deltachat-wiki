---
title: استفاده عملی از CRDT
description: مستندات استفاده عملی از CRDT برای webxdc.
category: وضعیت مشترک
---

# استفاده عملی از CRDT

اگر دو فصل قبلی را خوانده‌اید
باید درک خوبی از CRDT داشته باشید
و شرایطی که می‌توانند ابزارهای مفیدی باشند.
در غیر این صورت، اگر به نظریه علاقه‌ای ندارید
و ترجیح می‌دهید مستقیماً با مثال‌های عملی شروع کنید، این صفحه برای شماست.
تمرکز ما بر [Yjs](https://github.com/yjs/yjs/)
و به‌ویژه نحوه ادغام آن در یک برنامه webxdc خواهد بود.

## Yjs چیست؟

**Yjs** یک کتابخانه CRDT پرکاربرد نوشته شده در JavaScript است
که از تعدادی نوع داده پیچیده پشتیبانی می‌کند،
از جمله آرایه‌ها، نقشه‌ها، متن (شامل متن غنی، نه فقط رشته‌ها) و XML.
در مقایسه با بسیاری از CRDTهای دیگر بسیار کارآمد است
از نظر فضا (مصرف دیسک و حافظه)،
زمان (تلاش محاسباتی مورد نیاز برای تدوین یک به‌روزرسانی جدید یا اعمال یکی که توسط کلاینت دور نوشته شده)،
و هزینه انتقال شبکه (اندازه به‌روزرسانی‌های ارسال شده به کلاینت‌های دیگر از طریق اینترنت).

Yjs به گونه‌ای طراحی شده که نسبت به شبکه بی‌تفاوت است،
یعنی اهمیتی نمی‌دهد که آیا به‌طور مطمئن آنلاین است،
یا دستگاه یک کلاینت چگونه ممکن است
به دستگاه دیگری متصل شود وقتی اتصال شبکه در دسترس است.
معمولاً این به معنای آن است که مسئولیت نویسنده برنامه است
که اتصال بین کتابخانه و کلاینت‌های دور را فراهم کند،
اما Yjs از [_Providerها_](https://github.com/yjs/yjs/#providers) پشتیبانی می‌کند
که جزئیات پیچیده آن فرآیند را مدیریت می‌کنند.
برای نویسندگان برنامه webxdc، از قبل
یک [provider Yjs برای webxdc](https://codeberg.org/webxdc/y-webxdc) موجود است.
علاوه بر ساده‌سازی توسعه اولیه برنامه،
aستفاده از providerها انتقال برنامه‌ها به پلتفرم‌های دیگر
یا انتقال برنامه‌های موجود مبتنی بر Yjs به webxdc را آسان‌تر می‌کند.

کتابخانه تحت شرایط
[مجوز MIT](https://choosealicense.com/licenses/mit/) بسیار آزاد در دسترس است،
به این معنی که می‌تواند به راحتی در هر برنامه webxdc گنجانده شود
چه سورس عمومی باشد چه نباشد.

## چگونه کار می‌کند؟

هسته هر برنامه مبتنی بر Yjs _سند_ آن است:

```javascript
import * as Y from 'yjs';

const ydoc = new Y.Doc();
```

هر زمان که این سند تغییر کند، رویدادهای `update` منتشر می‌کند.
قبل از ایجاد هرگونه تغییر محلی
مهم است که یک listener رویداد برای مدیریت این به‌روزرسانی‌ها تنظیم کنید.

```javascript
ydoc.on('update', (update) => {
    console.log(update);
    /* send the emitted update to remote clients */
});
```

### رمزگذاری به‌روزرسانی‌ها و مدیریت تحویل

به‌روزرسانی‌ها به صورت
[Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) رمزگذاری می‌شوند،
نوعی از [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)
که فقط می‌تواند اعداد صحیح بدون علامت ۸ بیتی
(اعداد کامل بین `0` و `255`) به عنوان عناصر داشته باشد:

```javascript
Uint8Array(20) [
    1,   1, 253, 161, 163, 244,  12,
    0,   8,   1,   5, 111, 114, 100,
  101, 114,   1, 125,   5,   0
]
```

در برخی شرایط می‌توان آن را به فرمت باینری از طریق شبکه ارسال کرد،
اما [به‌روزرسانی‌های webxdc](../specification/sendUpdate.html)
اجازه داده‌های باینری در payloadهای خود را نمی‌دهند.
این نیاز به تبدیل آن به فرمت رشته‌ای قابل سریال‌سازی
مانند [Base64](https://developer.mozilla.org/en-US/docs/Glossary/Base64) ایجاد می‌کند.
تبدیل را می‌توان با ماژول npm مانند [js-base64](https://www.npmjs.com/package/js-base64) انجام داد،
یا از طریق قطعه کدهای زیر برگرفته از مستندات وب MDN:


```javascript
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}

function bytesToBase64(bytes) {
    const binString = String.fromCodePoint(...bytes);
    return btoa(binString);
}
```

بنابراین، یک به‌روزرسانی می‌تواند به این صورت مدیریت شود:

```javascript
ydoc.on('update', (update) => {
    const base64 = bytesToBase64(update);
    webxdc.sendUpdate({
        payload: base64,
        info: 'A new update for your Yjs app',
    }, 'Yjs update');
});
```

برنامه همچنین نیاز به یک listener مربوطه برای بارگذاری به‌روزرسانی‌های قبلی
و مدیریت رویدادهای ورودی از کلاینت‌های دیگر به صورت بلادرنگ دارد.

```javascript
webxdc.setUpdateListener((update) => {
    const decoded = base64ToBytes(update.payload);
    Y.applyUpdate(ydoc, decoded);
});
```

لایه انتقال زیرین برنامه‌های webxdc معمولاً سربار اندازه‌ای اضافه می‌کند،
و Yjs قادر است وقتی چندین به‌روزرسانی در یکی بسته‌بندی شوند فضا صرفه‌جویی کند،
بنابراین ارسال یک به‌روزرسانی برای هر تغییر جزئی ناکارآمد است.
این قطعه کدها به عنوان مثال‌هایی برای کمک به درک نحوه کار برنامه‌های webxdc مبتنی بر Yjs آورده شده‌اند،
اما برای استفاده عملی احتمالاً ترجیح می‌دهید از
[provider y-webxdc](https://codeberg.org/webxdc/y-webxdc) استفاده کنید
که صفی از به‌روزرسانی‌ها نگهداری می‌کند که به‌طور دوره‌ای بسته‌بندی
و به عنوان یک به‌روزرسانی واحد ارسال می‌شوند.

### استفاده از نوع‌های مشترک

یک سند Yjs اساساً مجموعه‌ای از تمام نوع‌های مشترک است
که برنامه شما برای تکرار بین همتاها نیاز دارد.
پس از ایجاد نمونه سند
و اتصال به webxdc می‌توانید شروع به افزودن داده به آن کنید.

#### آرایه‌ها

قطعه کد زیر یک [آرایه Yjs](https://docs.yjs.dev/api/shared-types/y.array) ایجاد می‌کند
که مشابه اما نه یکسان با یک آرایه معمولی JavaScript است.

```javascript
// myList is a reference to a named part of the top-level Yjs document
const myList = ydoc.getArray('myList');

// pushing to the array modifies it and triggers an update
myList.push(['a', 'b']);
```

فرض کنید تغییرات بالا توسط یک کلاینت (_آلیس_) ایجاد شده،
در حالی که کلاینت دیگری (_باب_) هم‌زمان مقادیر متفاوتی را به آرایه اضافه کرد:

```javascript
const myList = ydoc.getArray('myList');
myList.push(['c']);
```

هر دو کلاینت سعی کردند تغییرات خود را به انتهای یک آرایه خالی اضافه کنند.
آلیس دو رشته خود را به عنوان یک عملیات واحد اضافه کرد،
بنابراین مشخص است که او قصد دارد آن دو آیتم کنار هم باشند.
باب فقط یک آیتم اضافه کرد.

امکان اعمال هر دو عملیات وجود دارد، اما
مبهم است کدام باید اول اعمال شود.
Yjs چنین تغییراتی را با استفاده از شناسه‌های کلاینت مربوطه
(اعداد صحیح تصادفی خودتخصیصی) برای شکستن تساوی حل می‌کند.
بسته به شناسه‌های کلاینت، نتیجه یا

1. `['a', 'b', 'c']`

...یا

2. `['c', 'a', 'b']`

#### نقشه‌ها

Yjs توسط نویسنده‌اش به عنوان یک _Sequence CRDT_ توصیف شده،
یعنی تمام نوع‌های مشترک آن
به صورت داخلی به عنوان دنباله‌ای از مقادیر نمایش داده می‌شوند.
این ممکن است برای _آرایه‌ها_ نسبتاً شهودی باشد،
اما بسیار کمتر واضح است که چگونه یک نقشه ممکن است
با آن نمایش زیرین پیاده‌سازی شود.
توضیح این است که هر مقدار در نقشه به عنوان _دنباله خودش_ ذخیره می‌شود،
و مقدار سطحی از آخرین عنصر دنباله مشتق می‌شود.

[نقشه‌های Yjs](https://docs.yjs.dev/api/shared-types/y.map) به روش مشابهی با آرایه‌ها تعریف می‌شوند:

```javascript
const mymap = ydoc.getMap('mymap');
```

...از اینجا، آلیس و باب می‌توانند تغییرات هم‌زمان روی نقشه‌های محلی خود اعمال کنند:

```javascript
// Alice makes two consecutive changes

mymap.set('value', 'a');
mymap.set('value', 'b');
```

```javascript
// Bob makes a single change to the same attribute on his map
mymap.set('value', 'c');
```

مانند مثال _آرایه_ قبلی،
Yjs می‌تواند از زمینه تشخیص دهد که
دو مقدار متوالی آلیس رابطه معناداری دارند،
یعنی آلیس قصد داشته `"b"` جایگزین مقدار قبلی `"a"` شود.
هنگام چیدمان این مقادیر در یک دنباله،
اطمینان حاصل می‌کند که آن‌ها کنار هم بمانند
و ترتیبشان حفظ شود.
مانند قبل، دو چیدمان به یک اندازه معتبر وجود دارد،
و Yjs می‌تواند به‌صورت دلخواه بر اساس شناسه‌های کلاینت نویسندگان تصمیم بگیرد که کدام را انتخاب کند، یا:

1. `['a', 'b', 'c']`

...یا

2. `['c', 'a', 'b']`

مقدار نهایی mymap.value بنابراین آخرین عنصر
هر یک از این دنباله‌ها خواهد بود (`'c'` یا `'b'`).

#### متن

[نوع متن Yjs](https://docs.yjs.dev/api/shared-types/y.text)
باز هم از [نوع رشته بومی JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) متفاوت است.
قصد دارد نه فقط متن ساده،
بلکه متن غنی با قالب‌بندی بسیار پیچیده را نمایش دهد.

مانند همه نوع‌های دیگر،
عناصر _متن_ به عنوان بخشی از سند Yjs ایجاد می‌شوند
و به صورت داخلی به عنوان دنباله نمایش داده می‌شوند.
هر نود متنی می‌تواند به‌صورت اختیاری اطلاعات قالب‌بندی مرتبط داشته باشد،
و مگر اینکه با جزئیات داخلی ویرایشگرهای متن تجربه داشته باشید
API مدیریت این می‌تواند کاملاً ترسناک باشد.
خوشبختانه، تعدادی ویرایشگر متن‌باز مبتنی بر Yjs وجود دارد،
بنابراین به جای مدیریت مستقیم نودهای متن
و سبک‌ها، عملی‌تر است که یکی از
[اتصالات ویرایشگر](https://docs.yjs.dev/ecosystem/editor-bindings) موجود را انتخاب کنید
و مثال‌های آن‌ها را متناسب نیازهای خود سازگار کنید.

[برنامه ویرایشگر webxdc](https://codeberg.org/webxdc/editor)
می‌تواند به عنوان مثالی از نحوه استفاده از Prosemirror
و provider Yjs webxdc با ارسال ساده کل سند Yjs عمل کند.
به‌عنوان جایگزین، [اتصال ویرایشگر y-quill](https://github.com/yjs/y-quill/)
به یک نمونه واحد از نوع متن متصل می‌شود،
که ممکن است در صورتی که برنامه شما به
تعدادی فیلد متنی مشارکتی به جای یک ویرایشگر مشترک واحد نیاز داشته باشد مناسب‌تر باشد.

#### XML

Yjs از تعدادی نوع دیگر مرتبط با XML پشتیبانی می‌کند:

* [XmlElements](https://docs.yjs.dev/api/shared-types/y.xmlelement)
* [XmlFragments](https://docs.yjs.dev/api/shared-types/y.xmlfragment)
* [XmlText](https://docs.yjs.dev/api/shared-types/y.xmltext)

مانند متن، این نوع‌ها بسیار قدرتمند هستند،
اما استفاده از آن‌ها هم می‌تواند کاملاً دشوار باشد.
آن‌ها به شما امکان تکرار یک ساختار سند XML پیچیده
متشکل از تگ‌ها با ویژگی‌های دلخواه و نودهای متنی تودرتو را می‌دهند.
علاوه بر پیچیدگی کار با
یک ساختار درختی به‌طور دلخواه پیچیده،
مسائل امنیتی احتمالی نیز وجود دارد،
زیرا ممکن است کاربران دیگر بتوانند اسکریپت‌هایی را در چنین اسنادی تزریق کنند
و بسته به نحوه استفاده شما، اجرای کد روی دستگاه‌های دور را فعال کنند.

## تست

در بیشتر موارد نیازی به بررسی دقیق
نحوه حل عملیات هم‌زمان نیست، با این حال
داشتن درک پایه‌ای از این اصول ممکن است به جلوگیری از موارد لبه‌ای غافلگیرکننده کمک کند.
Yjs کار نسبتاً خوبی در مطابقت با انتظارات اکثر افراد
درباره نحوه مدیریت تناقضات انجام می‌دهد،
اما در صورت شک بهتر است فرضیات خود را صریحاً تست کنید.

امکان تست شرایط مختلف با ایجاد نمونه
دو یا چند سند در یک اسکریپت واحد
و اعمال دستی عملیات با ترتیب‌های مختلف
برای تأیید اینکه آیا نتایج مورد انتظار تولید می‌شوند وجود دارد.


```javascript
import * as Y from 'yjs';

const docA = new Y.Doc();
const docB = new Y.Doc();

// define arrays to store each document's pending operations
const aOperations = [];
const bOperations = [];

// listen for update events and store them in the array
docA.on('update', (update) => aOperations.push(update));
docB.on('update', (update) => bOperations.push(update));

// copy references to both local arrays
const aList = docA.getArray('list');
const bList = docB.getArray('list');

// make concurrent overlapping changes to both arrays
aList.push([5]);
bList.push([7]);

// apply A's updates to B
aOperations.forEach(update => {
    Y.applyUpdate(docB, update);
});

// apply B's updates to A
bOperations.forEach(update => {
    Y.applyUpdate(docA, update);
});

// we expect A and B to be equal
// stringifying is a cheap way to compare object equality
// if we know their keys will be in the order
if (JSON.stringify(aList) !== JSON.stringify(bList)) {
    throw new Error("A and B did not converge!");
}

// it is not easy to know which of two outcomes will occur
// but we can prepare an array of valid outcomes
// and check that the eventual result is in that array
const expected = [
    [5,7],
    [7,5]
].map(array => JSON.stringify(array));

// throw an error if an unexpected result occurs
[
    aList,
    bList
].forEach(array => {
    const stringified = JSON.stringify(array);
    if (!expected.includes(stringified)) {
        throw new Error("CRDT output did not match expected values");
    }
});
```

موارد تست حداقلی مانند این می‌توانند
شهود شما درباره نحوه عملکرد Yjs
یا هر CRDT دیگری در عمل را تأیید یا رد کنند.
این هرچه ساختار سند شما پیچیده‌تر شود
aهمیت بیشتری پیدا می‌کند.

## ساختارهای تودرتو

مستندات Yjs روش دیگری برای اعلان نوع‌های مشترک توصیف می‌کنند
که در مثال‌های بالا نشان داده نشده:

```javascript
// the basic way

// Method 1: Define a top-level type
const ymap = ydoc.getMap('my map type')
// Method 2: Define Y.Map that can be included into the Yjs document
const ymapNested = new Y.Map()

// Nested types can be included as content into any other shared type
ymap.set('my nested map', ymapNested)
```

این یک حوزه است که ممکن است تأیید اینکه
عملیات هم‌زمان مختلف همان‌طور که انتظار می‌رود رفتار می‌کنند اهمیت خاصی داشته باشد.
برای مثال، اگر یک کلاینت فیلدی به یک نقشه تودرتو اضافه کند
در حالی که کلاینت دیگری آن نقشه را حذف کند،
آنگاه افزودن فیلد جدید هیچ اثری نخواهد داشت.
در اکثر شرایط این با شهود افراد مطابقت دارد،
اما برخی موارد لبه‌ای غافلگیرکننده وجود دارد که باید در نظر گرفته شوند.

یک مورد لبه‌ای قابل توجه به این دلیل رخ می‌دهد که
Yjs مکانیزمی برای بیان قصد _جابه‌جایی_
یک مقدار از یک مکان به مکان دیگر ارائه نمی‌دهد،
بلکه توسعه‌دهندگان را مجبور می‌کند از مکان اصلی حذف کنند
و یک کپی در مکان جدید درج کنند.
در برنامه‌هایی که چنین رویه‌ای به‌طور مکرر رخ می‌دهد
aحتمال بیشتری وجود دارد که تغییر یک کلاینت
به‌طور بی‌سر و صدا نادیده گرفته شود زیرا کلاینت دیگری آیتمی را جابه‌جا کرده.

## طراحی ساختمان‌های داده

یک ساختار سند خوب مشخص شده می‌تواند رفتار غافلگیرکننده را در برنامه کمتر محتمل کند.
یک برنامه لیست کارهای چند کاربره را در نظر بگیرید،
که در آن کاربران می‌توانند به‌صورت مشارکتی کارت‌هایی با
داده‌های متنوع مانند عناوین، توضیحات، تاریخ‌های تکمیل مورد انتظار
و چک‌باکسی برای نشان دادن تکمیل آن ایجاد، جابه‌جا و حذف کنند.

یک راه برای نمایش این داده‌ها آرایه‌ای از نقشه‌ها است.

```json
[
    {
        title: "wash dishes",
        description: "don't forget the thermos in your bag",
        complete: false
    },
    {
        title: "water houseplants",
        description: "don't overwater the aloe or it will get mites",
        complete: false
    }
]
```

همان‌طور که در بخش قبلی ذکر شد،
تغییر ترتیب _«آب دادن گل‌ها»_ به موقعیت بالا
به معنای حذف یکی و بازسازی آن در ابتدای آرایه است.
اگر کسی گل‌ها را آب داده
و کارت را هم‌زمان با آن جابه‌جایی به‌روزرسانی کرده باشد،
تغییر آن‌ها نادیده گرفته خواهد شد
و در وضعیت ناتمام باقی خواهد ماند،
که احتمال آب‌دهی بیش از حد به گل‌ها را افزایش می‌دهد.

یک ساختار جایگزین که از این مشکل جلوگیری می‌کند می‌تواند به این شکل باشد:

```json
{
    order: [
        "025322791196985772",
        "34064380536730887"
    ],
    cards: {
        "025322791196985772": {
            title: "wash dishes",
            description: "don't forget the thermos in your bag",
            complete: false
        },
        "34064380536730887": {
            title: "water houseplants",
            description: "don't overwater the aloe or it will get mites",
            complete: false
        }
    }
}
```

این ساختار به هر کارت یک شناسه تصادفی اختصاص می‌دهد،
مقادیر فیلدهای آن را در یک نقشه ذخیره می‌کند
که می‌توان با شناسه آن به آن ارجاع داد،
و ترتیب کارت‌ها را
با موقعیت شناسه در آرایه `order` نشان می‌دهد.
حذف یک شناسه از آرایه order
و درج مجدد آن در جای دیگر بر داده‌های زیرین کارت تأثیری نخواهد داشت،
که امکان ویرایش‌ها و عملیات جابه‌جایی هم‌زمان را فراهم می‌کند.

یک اثر جانبی این طراحی این است که
حذف یک شناسه از آرایه `order`
داده‌های مرتبط را به‌طور خودکار حذف نمی‌کند.
اگر این نادیده گرفته شود، داده‌های کارت‌های قدیمی
ممکن است فقط با گذشت زمان انباشته شوند.
این را می‌توان با گزینه‌ای برای مشاهده کارت‌های _آرشیو شده_ مدیریت کرد،
احتمالاً با گزینه‌ای برای حذف آن‌ها.

این رویکرد امکان برخی مشکلات جدید را معرفی می‌کند.
دو کلاینت می‌توانند کارت‌های خود را با شناسه مشترک ایجاد کنند،
که در این صورت داده‌های یکی ممکن است داده‌های دیگری را بازنویسی کند.
به‌طور مشابه، همان شناسه می‌تواند در دو مکان در آرایه `order` تزریق شود.

تضمین صفر درصد احتمال برخورد دشوار است،
اما در عمل اگر شناسه‌های تصادفی به‌اندازه کافی بلند باشند
بسیار بعید است که رخ دهند.
می‌توان آن‌ها را با پیشوند یک مقدار هر-کاربر
یا هر-دستگاه به شناسه حتی کمتر محتمل کرد،
همراه با بررسی‌هایی برای اطمینان از اینکه
شناسه قبل از استفاده توسط هیچ کلاینت دیگری شناخته نشده است.

در مورد مسئله شناسه‌های تکراری در آرایه `order`،
کد رندر که رابط کاربری برنامه را از این داده‌ها می‌سازد
می‌تواند عناصر تکراری را هنگام پیمایش نادیده بگیرد.

## بیشتر بیاموزید

مثال‌های بسیار بیشتری را می‌توان در
[مستندات Yjs](https://docs.yjs.dev/)
یا با بررسی [پروژه‌هایی که از Yjs استفاده کرده‌اند](https://docs.yjs.dev/) یافت
(اگرچه همه آن‌ها متن‌باز نیستند).

همچنین [انجمنی](https://discuss.yjs.dev/)
وجود دارد که کاربران و مشارکت‌کنندگان Yjs می‌توانند سؤال بپرسند یا بینش‌هایی را به اشتراک بگذارند.

نویسنده Yjs به‌طور گسترده درباره طراحی و پیاده‌سازی کتابخانه [نوشته](https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/)
و [صحبت](https://youtu.be/0l5XgnQ6rB4?si=TyPzJ1A0EQl8o1Zq) کرده است.

درباره جزئیات پیاده‌سازی خاص webxdc،
لیست [موضوع webxdc در انجمن delta.chat](https://support.delta.chat/c/webxdc/20) را امتحان کنید.

همچنین چندین برنامه webxdc مبتنی بر CRDT موجود هستند که می‌توان از آن‌ها به عنوان مرجع استفاده کرد:

* [webxdc/editor](https://codeberg.org/webxdc/editor)
(ذکر شده در بالا) استفاده از Yjs
با [prosemirror](https://prosemirror.net/)
و [y-webxdc-provider](https://npmjs.org/package/y-webxdc) را نشان می‌دهد
* [webxdc/checklist](https://codeberg.org/webxdc/checklist/)
از [Automerge CRDT](https://automerge.org/)
برای پیاده‌سازی لیست بررسی مشارکتی استفاده می‌کند
* [webxdc/pixel](https://codeberg.org/webxdc/pixel/)
یک نوع داده bitmap با اندازه ثابت
بدون وابستگی خارجی
با استفاده از [مُهرهای زمانی Lamport](https://en.wikipedia.org/wiki/Lamport_timestamp)
برای حل تغییرات هم‌زمان پیاده‌سازی می‌کند

