---
title: Обнаружение конфликтов
description: Документация по обнаружению конфликтов в webxdc.
category: Общее состояние
---

# Обнаружение конфликтов

Изменения общего состояния могут считаться конфликтными при выполнении двух условий:

1.  Они затрагивают перекрывающуюся часть структуры данных, например, если два пользователя одновременно пытаются изменить заголовок одного и того же элемента списка дел.

2.  Они являются [параллельными (concurrent)](https://ru.wikipedia.org/wiki/Параллельные_вычисления) — это означает, что участники системы не могут однозначно определить порядок, в котором они произошли.

*Параллельные обновления, затрагивающие несвязанные данные*, могут быть разрешены без проблем, так же как и *последовательные обновления связанных данных*.

С точки зрения клиента параллельностью можно пренебречь в схемах, использующих центральный сервер и всегда подключенных клиентов. Типичный пример такой модели — централизованные веб-приложения. Централизованные HTTP-серверы могут не только гарантировать [полный порядок](https://ru.wikipedia.org/wiki/Линейный_порядок) сообщений, но и авторитетно разрешать конфликты, предоставляя единый «источник истины» для всех экземпляров приложения.

В децентрализованной модели обмена сообщениями, и особенно при использовании сквозного шифрования, нельзя гарантировать ни полный порядок сообщений, ни наличие единого «источника истины».

## Разрешение конфликтов в приложениях webxdc

Многие приложения webxdc не способны порождать конфликты либо потому, что они не используют сетевой обмен данными, либо потому, что любая структура данных имеет только одного автора. Например, многие [игры webxdc](https://webxdc.org/apps/) имеют таблицу рекордов. Игровое приложение просто публикует результат игрока, а остальные участники собирают все поступающие данные и отображают их в виде отсортированного списка. В этом случае потеря или перестановка сообщений практически не создает проблем: рано или поздно все увидят примерно один и тот же список рекордов.

Стоит учитывать, что хост-приложение webxdc может позволять одному пользователю использовать несколько устройств. Например, приложение для управления паролями может использоваться в чате «Избранное» (Заметки для себя), чтобы состояние приложения синхронизировалось между устройствами одного пользователя. Такая многоустройственная среда уже представляет собой минимальную P2P-систему, где полный порядок сообщений не гарантирован и нет единого источника истины.

Приложения webxdc могут использовать [`webxdc.sendUpdate()`](../specification/sendUpdate.html#sendupdate) и [`setUpdateListener`](https://docs.webxdc.org/spec/setUpdateListener.html) для отправки и получения данных. В этом случае необходимо предусмотреть механизм, с помощью которого все клиенты смогут определить общий порядок обновлений или иным образом прийти к согласованному состоянию на разных устройствах после доставки всех сообщений.

Создание полноценного решения этой задачи нетривиально, но существуют относительно простые механизмы, обеспечивающие [частичный порядок](https://ru.wikipedia.org/wiki/Частично_упорядоченное_множество) обновлений.

## Частичный порядок

Может возникнуть соблазн добавить метку времени (timestamp) к каждому обновлению и упорядочивать их по этому значению. Однако часы на компьютерах могут быть неточными, поэтому полагаться на них рискованно: сообщения могут «приходить» из далекого прошлого или будущего. На более теоретическом уровне [время — величина субъективная](https://ru.wikipedia.org/wiki/Замедление_времени), поэтому в этом подходе есть фундаментальные изъяны даже при наличии идеально точных атомных часов.

Более надежным вариантом являются [логические часы](https://ru.wikipedia.org/wiki/Логические_часы), которые позволяют упорядочить большинство событий в нормальных условиях. Например, [метки Лампорта](https://ru.wikipedia.org/wiki/Алгоритм_Лампорта) включают порядковый номер в каждое обновление. Каждый раз счетчик увеличивается так, чтобы он был на единицу больше максимального известного значения. Наличие нескольких сообщений с одинаковым порядковым номером будет указывать на параллельность (concurrency).

Этот метод популярен благодаря своей относительной простоте и малым накладным расходам. Например, он используется в [Yjs](https://yjs.dev/), о котором речь пойдет далее.

Другой подход — более явный, но менее компактный — использование [криптографических хеш-функций](https://ru.wikipedia.org/wiki/Криптографическая_хеш-функция). Вместо одного счетчика сообщения содержат список хешей предыдущих сообщений, известных на момент создания текущего. Это позволяет обнаружить потерю сообщения или изменение истории. Вариации этой техники применяются в [Git](https://git-scm.com/), [BitTorrent](https://ru.wikipedia.org/wiki/BitTorrent), [Bitcoin](https://ru.wikipedia.org/wiki/Биткойн), [Matrix](https://ru.wikipedia.org/wiki/Matrix_(протокол)) и многих других протоколах.

Любая из этих техник вводит понятие *причинности* (causality). Методы разрешения конфликтов могут быть ресурсоемкими или требовать вмешательства человека. Отслеживание причинно-следственных связей и исключение конфликтов — эффективная «первая линия обороны» в одноранговых системах, где порядок сообщений не гарантирован.

Зная о том, как возникают конфликты в распределенных системах, и владея базовыми приемами снижения их частоты, мы можем перейти к изучению развивающейся технологии, созданной для их полного устранения.
