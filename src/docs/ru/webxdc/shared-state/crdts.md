---
title: Теория бесконфликтных реплицируемых типов данных (CRDT)
description: Документация по теории бесконфликтных реплицируемых типов данных (CRDT) для webxdc.
category: Общее состояние
---

# Теория бесконфликтных реплицируемых типов данных (CRDT)

В предыдущем разделе мы описали условия, при которых обновления общего состояния могут конфликтовать, и представили методы их выявления. Теперь мы рассмотрим [**бесконфликтные реплицируемые типы данных (CRDT)**](https://ru.wikipedia.org/wiki/CRDT) — технологию, которая автоматически разрешает такие изменения без необходимости в центральном авторитете.

Мы дадим определения специальным терминам, которые часто отпугивают новичков, приведем базовые примеры, очертим возможности и ограничения этой технологии, чтобы вы могли избегать ошибок, связанных с параллелизмом, и пользоваться всеми преимуществами приложений, работающих по принципу «сначала офлайн».

## Терминология

Как и обычный [тип данных](https://ru.wikipedia.org/wiki/Тип_данных), CRDT определяется набором возможных значений, набором допустимых операций над ними и их низкоуровневым представлением. Часто одну и ту же информацию можно представить разными способами. Понимание диапазона возможных значений и конкретных операций, необходимых для вашего случая, поможет выбрать наиболее эффективную конструкцию.

*CRDT* идут дальше базовых типов данных, встроенных в большинство языков программирования, так как они спроектированы для [репликации](https://ru.wikipedia.org/wiki/Репликация_(вычислительная_техника)) между несколькими процессами. Эти процессы могут работать на одной машине, но чаще они распределены по сети. Для этого CRDT обычно определяют дополнительные методы отслеживания состояния удаленных узлов (пиров), доставки минимального набора недостающих обновлений и подтверждения получения обновлений.

Самое главное: CRDT являются **бесконфликтными**. Это означает, что они спроектированы так, чтобы обрабатывать любую возможную комбинацию параллельных операций детерминированным (определенным) образом. Состояния узлов могут временно расходиться, но CRDT гарантирует [согласованность в конечном счете (eventual consistency)](https://ru.wikipedia.org/wiki/Согласованность_в_конечном_счёте): любые два узла, получившие один и тот же набор обновлений, в итоге придут к идентичному состоянию.

## Примеры

Реализовать [счетчик](https://ru.wikipedia.org/wiki/Счётчик) относительно просто по сравнению с другими типами данных. Если два человека хотят посчитать количество книг на двух полках, каждый может посчитать одну полку, а затем сложить результаты. Они также могут называть числа по мере обнаружения книг, прибавляя их к общей сумме. Порядок не имеет значения, так как сложение [коммутативно](https://ru.wikipedia.org/wiki/Коммутативность) (по крайней мере, для простых чисел). Важно понимать, что, несмотря на внешнее сходство, *счетчик* отличается от *числа*, так как число поддерживает множество операций (например, присваивание), которые нельзя применять в произвольном порядке. Ограничившись только сложением, мы гарантируем, что результаты у всех участников совпадут.

Рассмотрим более сложный пример: организаторам фестиваля нужно следить, чтобы количество людей в разных зонах не превышало норму. Счетчик можно вести, фиксируя людей на входах и выходах. Мы можем модифицировать нашу операцию, указывая *конкретную зону* и *изменение количества людей*. Когда три человека переходят из зоны А в зону Б, на контрольном пункте фиксируются два события: `update('A', -3); update('B', 3)`. Если контрольные пункты одной зоны могут обмениваться данными с небольшой задержкой, они смогут оперативно решать, пропускать ли новых участников.

Эти примеры описывают очень простые CRDT для узкого круга задач. Если ваша проблема хорошо ложится на коммутативные операции, возможно, стоит разработать специализированный CRDT — такие структуры не всегда требуют большой сложности.

На практике порядок операций часто имеет значение, особенно когда речь идет о списках или массивах. Если две параллельные операции добавляют элементы в конец списка, логично вставить их в произвольной последовательности. Например:

1.  *Алиса* и *Боб* одновременно добавляют элементы в свои локальные копии пустого списка (`let list = []`):
    *   Алиса делает `list.push(5)`
    *   Боб делает `list.push(7)`
2.  Когда они узнают об изменениях друг друга, система может автоматически разрешить это как `[5, 7]` или `[7, 5]`. В большинстве случаев оба варианта допустимы.
3.  Если появляется *Чарли*, узнает об обоих изменениях и пытается добавить еще один элемент, все ожидают увидеть его в конце:
    *   Чарли делает `list.push(11)`
4.  Допустимые результаты: `[5, 7, 11]` или `[7, 5, 11]`.

Существуют техники, позволяющие отличить параллельные операции от последовательных. Чтобы автоматически разрешать конфликты при возникновении параллельных операций, типы данных должны определять детерминированные стратегии выбора одного и того же порядка всеми участниками. Разные библиотеки CRDT могут использовать разные стратегии, но в большинстве случаев этот выбор не имеет принципиального значения, если соблюдаются базовые условия.

## Чего ожидать от CRDT

CRDT — это очень широкий класс структур данных с множеством вариантов реализации. Всех их объединяет гарантия *согласованности в конечном счете*: все участники системы придут к общему состоянию, как только получат один и тот же набор обновлений. Объединение данных происходит *автоматически*, независимо от порядка или степени их пересечения.

Тем не менее, будет ли это итоговое состояние соответствовать ожиданиям пользователей — вопрос *проектирования*. Если два узла одновременно увеличивают число с `5` до `6`, одна система может решить, что результатом должно быть `6`, а другая — что нужно применить инкремент дважды и получить `7`.

Если поведение базовых типов в универсальных библиотеках вроде [Yjs](https://yjs.dev/) не соответствует вашим ожиданиям, вы всё равно можете их использовать, составляя из простых типов более сложные. Например, *Yjs* рассматривает одновременные изменения числа как два присваивания. Если вы хотите, чтобы они обрабатывались как инкременты, вы можете хранить каждое добавление как новый элемент в массиве и суммировать их при необходимости. Многие приложения на базе CRDT следуют такому паттерну *схемы*, где действия пользователя переводятся в операции над общим состоянием, а удаленные изменения транслируются обратно в интерфейс.

Грамотно спроектированный CRDT берет на себя все аспекты упорядочивания сообщений, включая логические часы, обнаружение параллелизма и разрешение пересекающихся изменений. Это позволяет узлам накапливать обновления в офлайне и объединять их, как только связь восстановится. Хотя это очень удобно для разработчиков, вам всё равно придется учитывать особенности работы в сети. Состояние приложения в условиях *согласованности в конечном счете* следует воспринимать как субъективное. Это заметный сдвиг парадигмы, если вы привыкли к серверу как к единственному источнику истины. Логика, которую вы обычно считаете однозначной («да»/«нет»), здесь может вести себя скорее как «в данный момент» / «пока нет».

В этом разделе мы обсудили теоретические атрибуты CRDT. В следующем разделе мы приведем конкретные примеры использования **Yjs**, уделяя особое внимание тому, как решать типичные задачи в приложениях webxdc.
