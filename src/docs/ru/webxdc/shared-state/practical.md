---
title: Практическое использование CRDT
description: Документация по практическому использованию CRDT в webxdc.
category: Общее состояние
---

# Практическое использование CRDT

Если вы прочитали две предыдущие главы, то уже должны хорошо понимать, что такое CRDT и в каких случаях они полезны. Если же вам не интересна теория и вы предпочитаете сразу перейти к конкретным примерам, то эта страница для вас. Мы сосредоточимся на [Yjs](https://github.com/yjs/yjs/) и на том, как интегрировать эту библиотеку в приложение webxdc.

## Что такое Yjs?

**Yjs** — это широко используемая библиотека CRDT, написанная на JavaScript. Она поддерживает множество сложных типов данных, включая массивы (Arrays), словари (Maps), текст (Text, включая форматированный текст) и XML. Она очень эффективна по сравнению со многими другими CRDT с точки зрения занимаемого места (диск и память), скорости (вычислительные усилия на создание или применение обновлений) и сетевого трафика.

Yjs спроектирована так, чтобы не зависеть от сетевого протокола. Ей не важно, находится ли клиент постоянно в сети или как устройства соединяются друг с другом. Обычно ответственность за обеспечение связи между библиотекой и удаленными клиентами лежит на разработчике приложения, но Yjs поддерживает использование [_провайдеров_](https://github.com/yjs/yjs/#providers), которые берут на себя всю сложность этого процесса. Для разработчиков webxdc уже доступен [провайдер webxdc Yjs](https://codeberg.org/webxdc/y-webxdc). Использование провайдеров не только упрощает начальную разработку, но и облегчает перенос приложений на другие платформы или адаптацию существующих приложений на базе Yjs для webxdc.

Библиотека распространяется под очень либеральной [лицензией MIT](https://choosealicense.com/licenses/mit/), что позволяет легко включать её в любое приложение webxdc, независимо от того, является ли его исходный код открытым.

## Как это работает?

Основой любого приложения на базе Yjs является его *документ*:

```javascript
import * as Y from 'yjs';

const ydoc = new Y.Doc();
```

При каждом изменении этого документа генерируются события `update`. Важно настроить прослушиватель событий для обработки этих обновлений до того, как вы внесете какие-либо локальные изменения.

```javascript
ydoc.on('update', (update) => {
    console.log(update);
    /* отправить сгенерированное обновление удаленным клиентам */
});
```

### Кодирование обновлений и обработка доставки

Обновления кодируются как [Uint8Arrays](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) — это вид типизированного массива, элементами которого могут быть только 8-битные целые числа без знака (от `0` до `255`):

```javascript
Uint8Array(20) [
    1,   1, 253, 161, 163, 244,  12,
    0,   8,   1,   5, 111, 114, 100,
  101, 114,   1, 125,   5,   0
]
```

В некоторых случаях их можно передавать по сети в бинарном формате, но [обновления webxdc](../specification/sendUpdate.html) не допускают использование бинарных данных. Поэтому их необходимо преобразовывать в формат строки, подлежащий сериализации, например [Base64](https://developer.mozilla.org/ru/docs/Glossary/Base64). Это можно сделать с помощью npm-модуля (например, [js-base64](https://www.npmjs.com/package/js-base64)) или используя следующие фрагменты кода из документации MDN:

```javascript
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}

function bytesToBase64(bytes) {
    const binString = String.fromCodePoint(...bytes);
    return btoa(binString);
}
```

Таким образом, обработка обновления может выглядеть так:

```javascript
ydoc.on('update', (update) => {
    const base64 = bytesToBase64(update);
    webxdc.sendUpdate({
        payload: base64,
        info: 'Новое обновление для вашего приложения Yjs',
    }, 'Yjs update');
});
```

Приложению также потребуется соответствующий прослушиватель для загрузки прошлых обновлений и обработки входящих событий от других клиентов в реальном времени.

```javascript
webxdc.setUpdateListener((update) => {
    const decoded = base64ToBytes(update.payload);
    Y.applyUpdate(ydoc, decoded);
});
```

Транспорт в приложениях webxdc обычно дает накладные расходы на размер сообщений, а Yjs умеет экономить место при объединении нескольких обновлений в одно. Поэтому отправка обновления при каждом минимальном изменении неэффективна. Эти фрагменты приведены для понимания принципа работы, но на практике лучше использовать [провайдер y-webxdc](https://codeberg.org/webxdc/y-webxdc), который поддерживает очередь обновлений, периодически объединяет их и отправляет одной порцией.

### Использование общих типов (shared types)

Документ Yjs — это, по сути, коллекция всех общих типов, которые ваше приложение будет реплицировать. После создания документа и подключения его к webxdc вы можете начать добавлять в него данные.

#### Массивы (Arrays)

Ниже приведен пример создания [массива Yjs](https://docs.yjs.dev/api/shared-types/y.array), который похож на обычный массив JavaScript, но имеет отличия.

```javascript
// myList — это ссылка на именованную часть документа Yjs верхнего уровня
const myList = ydoc.getArray('myList');

// добавление элементов в массив изменяет его и вызывает обновление
myList.push(['a', 'b']);
```

Предположим, эти изменения внесла *Алиса*, а в это же время *Боб* добавил в массив другие значения:

```javascript
const myList = ydoc.getArray('myList');
myList.push(['c']);
```

Оба клиента попытались добавить элементы в конец пустого массива. Алиса добавила две строки одним действием, поэтому очевидно, что они должны идти вместе. Боб добавил только один элемент.

Yjs разрешает такие ситуации, используя идентификаторы клиентов (случайные целые числа), чтобы сделать выбор. В зависимости от ID клиентов результат будет либо:

1. `['a', 'b', 'c']`
2. `['c', 'a', 'b']`

#### Словари (Maps)

Автор Yjs описывает её как *последовательный CRDT* (Sequence CRDT). Это значит, что все общие типы внутри представлены как последовательности значений. Для массивов это интуитивно понятно, но для словарей (Maps) — не совсем. Секрет в том, что каждое значение в словаре хранится как *своя собственная последовательность*, а итоговое значение берется из последнего элемента этой последовательности.

[Словари Yjs](https://docs.yjs.dev/api/shared-types/y.map) определяются так же, как и массивы:

```javascript
const mymap = ydoc.getMap('mymap');
```

Алиса и Боб могут вносить одновременные изменения:

```javascript
// Алиса делает два последовательных изменения
mymap.set('value', 'a');
mymap.set('value', 'b');
```

```javascript
// Боб вносит одно изменение в тот же атрибут
mymap.set('value', 'c');
```

Как и в случае с массивом, Yjs понимает контекст: Алиса хотела, чтобы `"b"` заменило `"a"`. Поэтому при выстраивании последовательности эти значения останутся рядом и порядок будет сохранен. Опять же, на основе ID клиентов Yjs детерминированно выберет один из двух вариантов:

1. `['a', 'b', 'c']`
2. `['c', 'a', 'b']`

Итоговым значением `mymap.value` станет последний элемент последовательности (либо `'c'`, либо `'b'`).

#### Текст (Text)

[Тип данных Text в Yjs](https://docs.yjs.dev/api/shared-types/y.text) отличается от [нативного типа String в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String). Он предназначен для работы не только с обычным текстом, но и с форматированным текстом со сложной структурой.

API для управления текстовыми узлами может показаться сложным. К счастью, существует множество редакторов с открытым исходным кодом на базе Yjs. Вместо того чтобы управлять узлами вручную, практичнее выбрать одну из готовых [привязок для редакторов (editor bindings)](https://docs.yjs.dev/ecosystem/editor-bindings).

[Приложение-редактор webxdc](https://codeberg.org/webxdc/editor) может служить примером использования [Prosemirror](https://prosemirror.net/) и провайдера webxdc Yjs. Также существует [y-quill](https://github.com/yjs/y-quill/) для редактора Quill, что удобно, если в вашем приложении много отдельных текстовых полей для совместной работы.

#### XML

Yjs поддерживает типы, связанные с XML:

* [XmlElements](https://docs.yjs.dev/api/shared-types/y.xmlelement)
* [XmlFragments](https://docs.yjs.dev/api/shared-types/y.xmlfragment)
* [XmlText](https://docs.yjs.dev/api/shared-types/y.xmltext)

Это мощные, но сложные в использовании типы. Они позволяют реплицировать структуру XML-документа с тегами, атрибутами и вложенными узлами. Помимо технической сложности, при работе с XML важно помнить о безопасности: другие пользователи могут попытаться внедрить скрипты в такие документы, что может привести к выполнению вредоносного кода на удаленных устройствах.

## Тестирование

В большинстве случаев вам не нужно задумываться о том, как именно разрешаются конфликты. Однако базовое понимание этих принципов поможет избежать неприятных сюрпризов. Yjs хорошо справляется с ожиданиями большинства людей, но в случае сомнений лучше протестировать свои предположения.

Вы можете тестировать сценарии, создавая два или более документа в одном скрипте и вручную применяя операции в разном порядке.

```javascript
import * as Y from 'yjs';

const docA = new Y.Doc();
const docB = new Y.Doc();

// массивы для хранения невыполненных операций каждого документа
const aOperations = [];
const bOperations = [];

docA.on('update', (update) => aOperations.push(update));
docB.on('update', (update) => bOperations.push(update));

const aList = docA.getArray('list');
const bList = docB.getArray('list');

// вносим одновременные изменения в оба массива
aList.push([5]);
bList.push([7]);

// применяем обновления Алисы к документу Боба
aOperations.forEach(update => {
    Y.applyUpdate(docB, update);
});

// применяем обновления Боба к документу Алисы
bOperations.forEach(update => {
    Y.applyUpdate(docA, update);
});

// мы ожидаем, что A и B станут идентичными
if (JSON.stringify(aList) !== JSON.stringify(bList)) {
    throw new Error("Документы A и B не сошлись!");
}

// Проверяем, что результат соответствует одному из валидных вариантов
const expected = [
    [5,7],
    [7,5]
].map(array => JSON.stringify(array));

[aList, bList].forEach(array => {
    const stringified = JSON.stringify(array);
    if (!expected.includes(stringified)) {
        throw new Error("Результат CRDT не соответствует ожидаемым значениям");
    }
});
```

Подобные минимальные тесты помогут подтвердить вашу интуицию о работе Yjs или любого другого CRDT на практике, что становится особенно важным при усложнении структуры документа.

## Вложенные структуры

В документации Yjs описан еще один способ объявления общих типов:

```javascript
// Способ 1: Определить тип верхнего уровня
const ymap = ydoc.getMap('my map type')
// Способ 2: Определить Y.Map, который можно включить в документ
const ymapNested = new Y.Map()

// Вложенные типы могут быть включены в любой другой общий тип
ymap.set('my nested map', ymapNested)
```

Здесь особенно важно проверять поведение параллельных операций. Например, если один клиент добавляет поле во вложенный словарь (map), а другой в это же время удаляет этот словарь целиком, то добавление поля не возымеет эффекта. Обычно это совпадает с интуицией, но есть и неочевидные случаи.

Один из них связан с тем, что в Yjs нет механизма *перемещения* значения из одного места в другое. Разработчикам приходится удалять данные в одном месте и вставлять копию в другом. Если это происходит часто, повышается вероятность того, что изменения одного клиента будут «тихо» потеряны, потому что другой клиент в это время «переместил» (пересоздал) объект.

## Проектирование структур данных

Продуманная структура документа снижает вероятность странного поведения приложения. Рассмотрим совместный список дел (to-do list), где пользователи могут создавать, перемещать и удалять карточки с заголовками, описаниями, датами и отметками о выполнении.

Один из способов — массив словарей (Maps).

```json
[
    {
        "title": "помыть посуду",
        "description": "не забудь термос в сумке",
        "complete": false
    },
    {
        "title": "полить цветы",
        "description": "не перелей алоэ",
        "complete": false
    }
]
```

Как упоминалось выше, перенос задачи «полить цветы» на первое место будет означать удаление карточки и её создание в начале массива. Если кто-то в это же время отметит задачу как выполненную, его изменение будет проигнорировано (так как старая карточка удалена), и задача останется невыполненной.

Альтернативная структура, решающая эту проблему:

```json
{
    "order": [
        "025322791196985772",
        "34064380536730887"
    ],
    "cards": {
        "025322791196985772": {
            "title": "помыть посуду",
            "description": "не забудь термос в сумке",
            "complete": false
        },
        "34064380536730887": {
            "title": "полить цветы",
            "description": "не перелей алоэ",
            "complete": false
        }
    }
}
```

Здесь каждой карточке присваивается случайный ID. Данные карточки хранятся в словаре под этим ID, а порядок определяется положением ID в массиве `order`. Перемещение ID в массиве не затрагивает данные самой карточки, что позволяет одновременно редактировать её и менять порядок.

Побочный эффект: удаление ID из массива `order` не удаляет данные карточки автоматически. Это можно использовать для создания функции «архивирования» дел.

Риск коллизий ID (когда два клиента создают разные карточки с одинаковыми ID) крайне мал, если ID достаточно длинные. Эту вероятность можно свести к нулю, добавляя к ID префикс пользователя или устройства.

Если в массиве `order` по какой-то причине окажутся дубликаты ID, код отрисовки интерфейса может просто игнорировать повторы.

## Узнать больше

Множество примеров можно найти в [документации Yjs](https://docs.yjs.dev/) или изучая [проекты, использующие Yjs](https://docs.yjs.dev/).

Также существует [форум](https://discuss.yjs.dev/), где пользователи и разработчики Yjs делятся опытом.

Автор Yjs много [писал](https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/) и [рассказывал](https://youtu.be/0l5XgnQ6rB4?si=TyPzJ1A0EQl8o1Zq) о дизайне и реализации библиотеки.

Для подробностей разработки под webxdc посетите [раздел на форуме delta.chat](https://support.delta.chat/c/webxdc/20).

Примеры приложений webxdc на базе CRDT:
* [webxdc/editor](https://codeberg.org/webxdc/editor) — демонстирует использование Yjs с Prosemirror и провайдером y-webxdc-provider.
* [webxdc/checklist](https://codeberg.org/webxdc/checklist/) — использует CRDT-библиотеку Automerge для совместного списка дел.
* [webxdc/pixel](https://codeberg.org/webxdc/pixel/) — реализует совместное рисование (bitmap) без внешних зависимостей, используя метки Лампорта для разрешения конфликтов.
